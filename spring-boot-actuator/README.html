<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>Spring Boot - Docs</title>
	<link rel="stylesheet" href="../../../css/bootstrap.min.css">
  </head>
  
  <body>

    <div class="container">

       <h1>Spring Boot - Actuator</h1>

<blockquote>
<p><strong>Note:</strong> Some of this documentation covers concepts from other modules, it will be
cleaned up before the final release.</p>
</blockquote>

<p>The aim of this project is minimum fuss for getting applications up
and running in production, and in other environments.  There is a
strong emphasis on implementing RESTful web services but many features
are more generic than that.</p>

<p>|Feature |Implementation |Notes |
|---|---|---|
|Server   |Tomcat or Jetty  | Whatever is on the classpath |
|REST     |Spring MVC       | |
|Security |Spring Security  | If on the classpath |
|Logging  |Logback, Log4j or JDK | Whatever is on the classpath. Sensible defaults. |
|Database |HSQLDB or H2     | Per classpath, or define a DataSource to override |
|Externalized configuration | Properties or YAML | Support for Spring profiles. Bind automatically to @Bean. |
|Audit                      | Spring Security and Spring ApplicationEvent |Flexible abstraction with sensible defaults for security events |
|Validation                 | JSR-303    |If on the classpath |
|Management endpoints       | Spring MVC | Health, basic metrics, request tracing, shutdown, thread dumps |
|Error pages                | Spring MVC | Sensible defaults based on exception and status code |
|JSON                       |Jackson 2 | |
|ORM                        |Spring Data JPA | If on the classpath |
|Batch                      |Spring Batch | If enabled and on the classpath |
|Integration Patterns       |Spring Integration | If on the classpath |</p>

<p>For a quick introduction and to get started quickly with a new
project, carry on reading.  For more in depth coverage of the features
of Spring Boot Actuator, go to the
<a href="docs/Features.html">Feature Guide</a>.</p>

<h1>Getting Started</h1>

<p>You will need Java (6 at least) and a build tool (Maven is what we use
below, but you are more than welcome to use gradle).  These can be
downloaded or installed easily in most operating systems.  For Ubuntu:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">$ sudo apt-get install openjdk-6-jdk maven
</code></pre></div>
<!--FIXME: short instructions for Mac.-->

<h2>A basic project</h2>

<p>If you are using Maven create a really simple <code>pom.xml</code> with 2 dependencies:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;com.mycompany&lt;/groupId&gt;
  &lt;artifactId&gt;myproject&lt;/artifactId&gt;
  &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;&lt;/version&gt;
  &lt;/parent&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
     &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</code></pre></div>
<p>If you like Gradle, that&#39;s fine, and you will know what to do with
those dependencies.  The first dependency adds Spring Boot auto
configuration and the Tomcat container to your application, and the
second one adds some more opinionated stuff like the default
management endpoints.  If you prefer Jetty you can just add the
embedded Jetty jars to your classpath instead of Tomcat (once you
exclude the <code>spring-starter-tomcat</code> dependency).</p>

<h2>Adding a business endpoint</h2>

<p>To do something useful to your business you need to add at least one
endpoint.  An endpoint can be implemented as a Spring MVC
<code>@Controller</code>, e.g.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">@Controller
@EnableAutoConfiguration
public class SampleController {

  @RequestMapping(&quot;/&quot;)
  @ResponseBody
  public Map&lt;String, String&gt; helloWorld() {
    return Collections.singletonMap(&quot;message&quot;, &quot;Hello World&quot;);
  }

  public static void main(String[] args) throws Exception {
    SpringApplication.run(SampleController.class, args);
  }

}
</code></pre></div>
<p>You can use the main method to launch it from your project jar.  You
can also launch that straight using the Spring Boot CLI (without
the <code>@EnableAutoConfiguration</code> and even without the import statements
that your IDE will add if you are using one), if you just add</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">@Grab(&quot;org.springframework.boot:spring-boot-starter-actuator:&quot;)
</code></pre></div>
<p>and package and run:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">$ mvn package
$ java -jar target/myproject-1.0.0-SNAPSHOT.jar
$ curl localhost:8080/
{&quot;message&quot;: &quot;Hello World&quot;}
</code></pre></div>
<p>There are also some endpoins that you didn&#39;t implement by came free
with the Actuator:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">$ curl localhost:8080/health
ok
$ curl localhost:8080/metrics
{&quot;counter.status.200.health&quot;:1.0,&quot;gauge.response.health&quot;:10.0,&quot;mem&quot;:120768.0,&quot;mem.free&quot;:105012.0,&quot;processors&quot;:4.0}
</code></pre></div>
<p><code>/health</code> is the default location for the health endpoint - it tells
you if the application is running and healthy. <code>/metrics</code> is the default
location for the metrics endpoint - it gives you basic counts and
response timing data by default but there are plenty of ways to
customize it.  You can also try <code>/trace</code> and <code>/dump</code> to get some
interesting information about how and what your app is doing.</p>

<h2>Running the application</h2>

<p>You can package the app and run it as a jar (as above) and that&#39;s very
convenient for production usage.  Or there are other options, many of
which are more convenient at development time.  Here are a few:</p>

<ol>
<li><p>Use the Maven exec plugin, e.g.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">$ mvn exec:java
</code></pre></div></li>
<li><p>Run directly in your IDE, e.g. Eclipse or IDEA let you right click
on a class and run it.</p></li>
<li><p>Use a different Maven plugin.</p></li>
<li><p>Find feature in Gradle that does the same thing.</p></li>
<li><p>Use the Spring executable.  &lt;!--FIXME: document this maybe.--&gt;</p></li>
</ol>

<h2>Externalizing configuration</h2>

<p>Spring Boot likes you to externalize your configuration so you
can work with the same application code in different environments.  To
get started with this you create a file in the root of your classpath
(<code>src/main/resources</code> if using Maven) - if you like YAML you can call
it <code>application.yml</code>, e.g.:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">server:
  port: 9000
management:
  port: 9001
logging:
  file: target/log.out
</code></pre></div>
<p>or if you like Java <code>Properties</code> files, you can call it
<code>application.properties</code>, e.g.:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">server.port: 9000
management.port: 9001
logging.file: target/log.out
</code></pre></div>
<p>Those examples are properties that Spring Boot itself binds to
out of the box, so if you make that change and run the app again, you
will find the home page on port 9000 instead of 8080:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">$ curl localhost:9000/
{&quot;message&quot;: &quot;Hello World&quot;}
</code></pre></div>
<p>and the management endpoints on port 9001 instead of 8080:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">$ curl localhost:9001/health
ok
</code></pre></div>
<p>To externalize business configuration you can simply add a default
value to your configuration file, e.g.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">server:
  port: 9000
management:
  port: 9001
logging:
  file: target/log.out
service:
  message: Awesome Message
</code></pre></div>
<p>and then bind to it in the application code.  The simplest way to do
that is to simply refer to it in an <code>@Value</code> annotation, e.g.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">@Controller
@EnableAutoConfiguration
public class SampleController {

  @Value(&quot;${service.message:Hello World}&quot;)
  private String value = &quot;Goodbye Everypone&quot;

  @RequestMapping(&quot;/&quot;)
  @ResponseBody
  public Map&lt;String, String&gt; helloWorld() {
    return Collections.singletonMap(&quot;message&quot;, message);
  }

  ...
}
</code></pre></div>
<p>That&#39;s a little bit confusing because we have provided a message value
in three different places - in the external configuration (&quot;Awesome
Message&quot;), in the <code>@Value</code> annotation after the colon (&quot;Hello World&quot;),
and in the filed initializer (&quot;Goodbye Everyone&quot;).  That was only to
show you how and you only need it once, so it&#39;s your choice (it&#39;s
useful for unit testing to have the Java initializer as well as the
external value).  Note that the YAML object is flattened using period
separators.</p>

<p>For simple Strings where you have sensible defaults <code>@Value</code> is
perfect, but if you want more and you like everything strongly typed
then you can have Spring bind the properties and validate them
automatically in a separate value object.  For instance:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// ServiceProperties.java
@ConfigurationProperties(name=&quot;service&quot;)
public class ServiceProperties {
    private String message;
    private int value = 0;
    ... getters and setters
}

// SampleController.java
@Controller
@EnableAutoConfiguration
@EnableConfigurationProperties(ServiceProperties.class)
public class SampleController {

  @Autowired
  private ServiceProperties properties;

  @RequestMapping(&quot;/&quot;)
  @ResponseBody
  public Map&lt;String, String&gt; helloWorld() {
    return Collections.singletonMap(&quot;message&quot;, properties.getMessage());
  }

  ...
}
</code></pre></div>
<p>When you ask to
<code>@EnableConfigurationProperties(ServiceProperties.class)</code> you are
saying you want a bean of type <code>ServiceProperties</code> and that you want
to bind it to the Spring Environment.  The Spring Environment is a
collection of name-value pairs taken from (in order of decreasing
precedence) 1) the command line, 2) the external configuration file,
3) System properties, 4) the OS environment.  Validation is done based
on JSR-303 annotations by default provided that library (and an
implementation) is on the classpath.</p>

<h2>Adding security</h2>

<p>If you add Spring Security java config to your runtime classpath you
will enable HTTP basic authentication by default on all the endpoints.
In the <code>pom.xml</code> it would look like this:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
    &lt;/dependency&gt;
</code></pre></div>
<p>Try it out:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">$ curl localhost:8080/
{&quot;status&quot;: 403, &quot;error&quot;: &quot;Forbidden&quot;, &quot;message&quot;: &quot;Access Denied&quot;}
$ curl user:password@localhost:8080/
{&quot;message&quot;: &quot;Hello World&quot;}
</code></pre></div>
<p>The default auto configuration has an in-memory user database with one
entry.  If you want to extend or expand that, or point to a database
or directory server, you only need to provide a <code>@Bean</code> definition for
an <code>AuthenticationManager</code>, e.g. in your <code>SampleController</code>:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">@Bean
public AuthenticationManager authenticationManager() throws Exception {
  return new AuthenticationBuilder().inMemoryAuthentication().withUser(&quot;client&quot;)
      .password(&quot;secret&quot;).roles(&quot;USER&quot;).and().and().build();
}
</code></pre></div>
<p>Try it out:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">$ curl user:password@localhost:8080/
{&quot;status&quot;: 403, &quot;error&quot;: &quot;Forbidden&quot;, &quot;message&quot;: &quot;Access Denied&quot;}
$ curl client:secret@localhost:8080/
{&quot;message&quot;: &quot;Hello World&quot;}
</code></pre></div>
<h2>Adding a database</h2>

<p>Just add <code>spring-jdbc</code> and an embedded database to your dependencies:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;
        &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
    &lt;/dependency&gt;
</code></pre></div>
<p>Then you will be able to inject a <code>DataSource</code> into your controller:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">@Controller
@EnableAutoConfiguration
@EnableConfigurationProperties(ServiceProperties.class)
public class SampleController {

  private JdbcTemplate jdbcTemplate;

  @Autowired
  public SampleController(DataSource dataSource) {
    this.jdbcTemplate = new JdbcTemplate(dataSource);
  }

  @RequestMapping(&quot;/&quot;)
  @ResponseBody
  public Map&lt;String, String&gt; helloWorld() {
    return jdbcTemplate.queryForMap(&quot;SELECT * FROM MESSAGES WHERE ID=?&quot;, 0);
  }

  ...
}
</code></pre></div>
<p>The app will run (going back to the default security configuration):</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">       $ curl user:password@localhost:8080/
       {&quot;error&quot;:&quot;Internal Server Error&quot;, &quot;status&quot;:500, &quot;exception&quot;:...}
</code></pre></div>
<p>but there&#39;s no data in the database yet and the <code>MESSAGES</code> table
 doesn&#39;t even exist, so there&#39;s an error.  One easy way to fix it is
 to provide a <code>schema.sql</code> script in the root of the classpath, e.g.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">create table MESSAGES (
  ID BIGINT NOT NULL PRIMARY KEY,
  MESSAGE VARCHAR(255)
);
INSERT INTO MESSAGES (ID, MESSAGE) VALUES (0, &#39;Hello Phil&#39;);
</code></pre></div>
<p>Now when you run the app you get a sensible response:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">   $ curl user:password@localhost:8080/
   {&quot;ID&quot;:0, &quot;MESSAGE&quot;:&quot;Hello Phil&quot;}
</code></pre></div>
<p>Obviously, this is only the start, but hopefully you have a good grasp
of the basics and are ready to try it out yourself.</p>


    </div>

	<script type="text/javascript" src="http://www.websequencediagrams.com/service.js"></script>

  </body>
</html>
